---
layout: post 
title: 双因素认证（TOTP）基于时间的一次性密码
---

# 需求背景

客户需要在账号、密码、验证码登陆后还需要一步验证，但是由于机器无法连接外网，所以验证码、邮箱等不在考虑范围内。

# 解决方案

通过调研采用TOTP基于时间的一次性密码

## 已下是TOTP的实现原理

1.预共享密钥（Shared Secret Key）：用户在绑定软件令牌应用程序时，服务器会生成一个密钥并与用户账户关联。这个密钥是一个与服务器之间共享的机密值。

2.时间戳：TOTP 使用当前的时间作为参数来生成密码。时间戳通常以 Unix 时间（自1970年1月1日以来经过的秒数）的形式表示，并以固定时间间隔（例如30秒）递增。

3.HMAC-SHA1 哈希函数：TOTP 使用 HMAC-SHA1 哈希函数，其中 HMAC（Hash-based Message Authentication Code）是一种结合密钥和消息进行身份验证的算法。HMAC-SHA1
以密钥和输入数据作为输入，并生成一个固定长度的哈希值。

4.密钥衍生：根据时间戳和预共享密钥，将其作为输入传递给 HMAC-SHA1 哈希函数，生成一个哈希值。

5.动态密码生成：从哈希值中提取一个固定长度的动态密码。通常，从哈希值中选择一个偏移量，并提取连续的4或6位数字，作为动态密码。

6.显示和验证：软件令牌应用程序将生成的动态密码显示给用户。用户在进行身份验证时，将动态密码输入到身份验证页面或应用程序中。服务器也使用相同的密钥和时间戳生成一个期望的动态密码，并将其与用户输入的动态密码进行比较。如果两者匹配，则身份验证成功。

# 实现

- 用户账号密码、验证码登录通过后，通过AES加密用户的信息返回sign签名信息
- 输入双因素的生成的动态密码，带着sign请求接口
- 通过解密sign获取用户信息，间接获取用户双因素密钥。通过密钥验证动态密码

## 代码
```python
# demo
import pyotp

# 生成的密钥
secret_key = pyotp.random_base32()

# 创建一个 TOTP 对象
totp = pyotp.TOTP(secret_key)
user_code = 1111111  # 用户端生成的动态密码
# 验证代码是否正确
if totp.verify(user_code):
    print('两步验证成功！')
else:
    print('两步验证失败！')
```
# 工具
- 使用支持双因数认证的工具（我这边使用的google的）

![img.png](/images/blog/2023-07-12.png)
